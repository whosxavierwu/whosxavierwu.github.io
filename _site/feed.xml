<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-05-31T23:13:01+08:00</updated><id>http://localhost:4000/</id><title type="html">whosxavierwu’s blog</title><subtitle>Keep learning, deep learning. </subtitle><entry><title type="html">TODO LeetCode #22</title><link href="http://localhost:4000/leetcode/2018/05/31/leetcode-22.html" rel="alternate" type="text/html" title="TODO LeetCode #22" /><published>2018-05-31T23:11:00+08:00</published><updated>2018-05-31T23:11:00+08:00</updated><id>http://localhost:4000/leetcode/2018/05/31/leetcode-22</id><content type="html" xml:base="http://localhost:4000/leetcode/2018/05/31/leetcode-22.html">&lt;p&gt;（待填坑）&lt;/p&gt;

&lt;p&gt;最近重新开始刷题。&lt;/p&gt;</content><author><name></name></author><summary type="html">（待填坑）</summary></entry><entry><title type="html">TODO Exercises of ESL Chap.2</title><link href="http://localhost:4000/esl/2018/05/31/esl-2.html" rel="alternate" type="text/html" title="TODO Exercises of ESL Chap.2" /><published>2018-05-31T23:02:00+08:00</published><updated>2018-05-31T23:02:00+08:00</updated><id>http://localhost:4000/esl/2018/05/31/esl-2</id><content type="html" xml:base="http://localhost:4000/esl/2018/05/31/esl-2.html">&lt;p&gt;（待填坑）&lt;/p&gt;

&lt;p&gt;近期重新拿起了经典的 “The Elements of Statistical Learning” 来好好学习。&lt;/p&gt;</content><author><name></name></author><summary type="html">（待填坑）</summary></entry><entry><title type="html">TODO 实时标签</title><link href="http://localhost:4000/work/2018/05/31/realtime-tag.html" rel="alternate" type="text/html" title="TODO 实时标签" /><published>2018-05-31T23:01:00+08:00</published><updated>2018-05-31T23:01:00+08:00</updated><id>http://localhost:4000/work/2018/05/31/realtime-tag</id><content type="html" xml:base="http://localhost:4000/work/2018/05/31/realtime-tag.html">&lt;p&gt;（待填坑）&lt;/p&gt;

&lt;p&gt;最近新接手的任务——用户实时标签生成。&lt;/p&gt;</content><author><name></name></author><summary type="html">（待填坑）</summary></entry><entry><title type="html">TODO 流量预估</title><link href="http://localhost:4000/work/2018/05/31/impose-predict.html" rel="alternate" type="text/html" title="TODO 流量预估" /><published>2018-05-31T23:00:00+08:00</published><updated>2018-05-31T23:00:00+08:00</updated><id>http://localhost:4000/work/2018/05/31/impose-predict</id><content type="html" xml:base="http://localhost:4000/work/2018/05/31/impose-predict.html">&lt;p&gt;（待填坑）&lt;/p&gt;

&lt;p&gt;最近在做的一个小需求——广告流量预估。这个需求给我带来的收获更多的是技术以外的经验。&lt;/p&gt;</content><author><name></name></author><summary type="html">（待填坑）</summary></entry><entry><title type="html">阶段总结-跳槽</title><link href="http://localhost:4000/thinking/2018/05/26/review.html" rel="alternate" type="text/html" title="阶段总结-跳槽" /><published>2018-05-26T17:20:00+08:00</published><updated>2018-05-26T17:20:00+08:00</updated><id>http://localhost:4000/thinking/2018/05/26/review</id><content type="html" xml:base="http://localhost:4000/thinking/2018/05/26/review.html">&lt;p&gt;三月底开始投简历、约面试，清明几天打飞的来北京密集面试，最终敲定的是汽车之家的offer，五月下旬入职。&lt;/p&gt;

&lt;p&gt;两个多月的时间里发生了不少事情，这里做点总结。大体上，跳槽可以分为这么几个阶段：&lt;/p&gt;

&lt;h1 id=&quot;一准备阶段&quot;&gt;一、准备阶段&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;明确动机。是确定了要跳槽，还是单纯想了解市场情况？后者随意，前者需要留意”金三银四”的时间，提前准备。&lt;/li&gt;
  &lt;li&gt;明确方向。确定期望的城市、岗位、薪酬、公司类型等，上拉勾等招聘网站更新基本信息，并持续关注。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我就是因为没有做好以上两点，后面一直很被动。&lt;/p&gt;

&lt;h1 id=&quot;二简历阶段&quot;&gt;二、简历阶段&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;用心！用心！用心！
别高估了自己的抢手程度，对简历要多上点心。
STAR法则、岗位职责、岗位要求等等，都好好理解一下。&lt;/li&gt;
  &lt;li&gt;不要脸！不要脸！不要脸！
尽可能找人内推。
简历也让同行朋友们给点建议。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用心去做一份好的简历是很花时间的，这也是前面强调提前准备的原因。&lt;/p&gt;

&lt;h1 id=&quot;三面试阶段&quot;&gt;三、面试阶段&lt;/h1&gt;
&lt;p&gt;就数据挖掘这一类岗位来看，面试一般会有这几方面的问题：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;编程基础。刷题！刷题！刷题！&lt;/li&gt;
  &lt;li&gt;理论基础。常用的模型要理解透彻了，要到能随手推导的程度。模型调用、调参都得比较熟悉。&lt;/li&gt;
  &lt;li&gt;项目经历。挑一两个跟应聘岗位相关的项目，着重说明，所用的算法模型、遇到的难题、解决思路、最终效果等等，都得搞清楚。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;面试阶段最最重要的是坚持！尽可能不要被前面发挥不好的面试所影响，而是要不断调整自己的面试策略、面试表现。
不到最后一刻不要放弃！&lt;/p&gt;

&lt;h1 id=&quot;四offer阶段&quot;&gt;四、offer阶段&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;对HR别轻易透底，让对方先开价。（你不知道我开价后发现HR开的价比我的更高时是有多后悔……）&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;其他发现与感想&quot;&gt;其他发现与感想&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;学历是有用的。数据挖掘岗把硕士定为门槛是很常见的事情。&lt;/li&gt;
  &lt;li&gt;所在公司是有影响的。从小公司出来面试时要解释这家公司做什么其实是挺麻烦的。&lt;/li&gt;
  &lt;li&gt;弱关系会在一些地方发挥着重要的作用。内推、招聘信息、租房信息等等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;平时积累最重要。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">三月底开始投简历、约面试，清明几天打飞的来北京密集面试，最终敲定的是汽车之家的offer，五月下旬入职。</summary></entry><entry><title type="html">序</title><link href="http://localhost:4000/others/2018/05/26/my-first-post.html" rel="alternate" type="text/html" title="序" /><published>2018-05-26T17:16:00+08:00</published><updated>2018-05-26T17:16:00+08:00</updated><id>http://localhost:4000/others/2018/05/26/my-first-post</id><content type="html" xml:base="http://localhost:4000/others/2018/05/26/my-first-post.html">&lt;p&gt;寻思写博客这事，也不是一天两天了。&lt;/p&gt;

&lt;p&gt;和大家一样，我知道写博客有各种好处；和绝大多数人一样，我也没能累积下来多少篇。
虽然不知道这次能坚持多久，但能写一篇算一篇吧。&lt;/p&gt;</content><author><name></name></author><summary type="html">寻思写博客这事，也不是一天两天了。</summary></entry><entry><title type="html">聚类算法总结 - Hierarchical Clustering</title><link href="http://localhost:4000/datamining/2015/09/24/hierarchical-clustering.html" rel="alternate" type="text/html" title="聚类算法总结 - Hierarchical Clustering" /><published>2015-09-24T16:22:00+08:00</published><updated>2015-09-24T16:22:00+08:00</updated><id>http://localhost:4000/datamining/2015/09/24/hierarchical-clustering</id><content type="html" xml:base="http://localhost:4000/datamining/2015/09/24/hierarchical-clustering.html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;算法&lt;/th&gt;
      &lt;th&gt;概括&lt;/th&gt;
      &lt;th&gt;优缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AGNES&lt;/td&gt;
      &lt;td&gt;典型的凝聚式层次聚类&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DIANA&lt;/td&gt;
      &lt;td&gt;典型的划分式层次聚类&lt;/td&gt;
      &lt;td&gt;划分式层次聚类的复杂度比凝聚式的大得多，所以较为少用。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CURE&lt;/td&gt;
      &lt;td&gt;用到了kd-tree跟heap。&lt;br /&gt;合并两个类的时候，先选若干well-scattered的点。从中挑出离中心最远的点，之后再挑离该点最远的点…如此得到一堆代表点，基于这些点去做层次聚类。&lt;br /&gt;&lt;br /&gt;对于大数据：先随机抽样，再对样本进行分区，然后对每个分区局部聚类，最后对局部聚类进行全局聚类。&lt;/td&gt;
      &lt;td&gt;时间上最坏是：$O(n^2log(n))$&lt;br /&gt;若数据维度较小，可以降到：$O(n^2)$&lt;br /&gt;空间复杂度是：$O(n)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROCK&lt;/td&gt;
      &lt;td&gt;1.生成相似度矩阵。&lt;br /&gt;2.根据相似度阈值得到邻居矩阵-A。&lt;br /&gt;3.计算链接矩阵-L=A x A &lt;br /&gt;4.计算相似性的度量（Goodness Measure），将相似性最高的两个对象合并。（用到了链接矩阵）&lt;br /&gt;&lt;br /&gt;ROCK算法首先用相似度阀值和共同邻居的概念，从给定的数据相似度矩阵中构建一个稀疏图，然后对该稀疏图使用分层聚类算法进行聚类&lt;/td&gt;
      &lt;td&gt;CURE算法不能处理枚举型数据，而ROCK算法是在CURE基础之上适用于枚举数据的聚结分层聚类算法。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Chameleon&lt;/td&gt;
      &lt;td&gt;1.由数据集构造成一个K-近邻图$G_k$&lt;br /&gt;2.通过图的划分算法将图$G_k$划分成大量的子图，每个子图代表一个初始子簇&lt;br /&gt;3.凝聚式层次聚类&lt;/td&gt;
      &lt;td&gt;Chameleon跟CURE和DBSCAN相比，在发现高质量的任意形状的聚类方面有更强的能力。但是，在最坏的情况下，高维数据的处理代价可能对n个对象需要$O(n^2)$的时间。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BIRCH&lt;/td&gt;
      &lt;td&gt;用到了$CF&amp;lt;n, LS, SS&amp;gt;$&lt;br /&gt;CF-tree类似于B-树，有两个参数：内部节点平衡因子$B$，叶节点平衡因子$L$，簇半径阈值$T$。&lt;br /&gt;&lt;br /&gt;1.自上而下选择最近的子节点&lt;br /&gt;2.到达子节点后，检查最近的元组$CF_i$能否吸收此数据点&lt;br /&gt;若能吸收，则更新CF值&lt;br /&gt;否则考虑是否可以添加一个新的元组&lt;br /&gt;如果可以，则添加一个新的元组&lt;br /&gt;否则，分裂最远的一对元组，作为种子，按最近距离重新分配其它元组&lt;br /&gt;3.更新每个非叶节点的CF信息，如果分裂节点，在父节点中插入新的元组，检查分裂，直到root&lt;/td&gt;
      &lt;td&gt;BIRCH优点：&lt;br /&gt;1.节省内存。叶子节点放在磁盘分区&lt;br /&gt;2. 在对树进行插入或查找操作很快。&lt;br /&gt;3.一遍扫描数据库即可建树。&lt;br /&gt;4.可识别噪声点。&lt;br /&gt;5. 可作为其他聚类算法的预处理过程&lt;br /&gt;&lt;br /&gt;BIRCH缺点：&lt;br /&gt;1.结果依赖于数据点的插入顺序。&lt;br /&gt;2.对非球状的簇聚类效果不好。&lt;br /&gt;3.对高维数据聚类效果不好。&lt;br /&gt;4.最后得出来的簇可能和自然簇相差很大。&lt;br /&gt;5.在整个过程中算法一旦中断，一切必须从头再来。&lt;br /&gt;6.局部性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*BUBBLE&lt;/td&gt;
      &lt;td&gt;把BIRCH算法的中心和半径概念推广到普通的距离空间&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;*BUBBLE-FM&lt;/td&gt;
      &lt;td&gt;通过减少距离的计算次数，提高了BUBBLE算法的效率&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Probabilistic agglomerative clustering&lt;/td&gt;
      &lt;td&gt;距离度量用：&lt;br /&gt;&lt;script type=&quot;math/tex&quot;&gt;dist(C_1,C_2 )=-log ((P(C_1∪C_2))/(P(C_1)P(C_2)) )&lt;/script&gt; &lt;br /&gt;如果dist小于零，则合并两个簇。&lt;/td&gt;
      &lt;td&gt;易于理解&lt;br /&gt;一般跟其他凝聚式层次聚类算法的效率差不多&lt;br /&gt;但是：it outputs only one hierarchy with respect to a chosen probabilistic model; it cannot handle the uncertainty of cluster hierarchies.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">算法 概括 优缺点 AGNES 典型的凝聚式层次聚类   DIANA 典型的划分式层次聚类 划分式层次聚类的复杂度比凝聚式的大得多，所以较为少用。 CURE 用到了kd-tree跟heap。合并两个类的时候，先选若干well-scattered的点。从中挑出离中心最远的点，之后再挑离该点最远的点…如此得到一堆代表点，基于这些点去做层次聚类。对于大数据：先随机抽样，再对样本进行分区，然后对每个分区局部聚类，最后对局部聚类进行全局聚类。 时间上最坏是：$O(n^2log(n))$若数据维度较小，可以降到：$O(n^2)$空间复杂度是：$O(n)$ ROCK 1.生成相似度矩阵。2.根据相似度阈值得到邻居矩阵-A。3.计算链接矩阵-L=A x A 4.计算相似性的度量（Goodness Measure），将相似性最高的两个对象合并。（用到了链接矩阵）ROCK算法首先用相似度阀值和共同邻居的概念，从给定的数据相似度矩阵中构建一个稀疏图，然后对该稀疏图使用分层聚类算法进行聚类 CURE算法不能处理枚举型数据，而ROCK算法是在CURE基础之上适用于枚举数据的聚结分层聚类算法。 Chameleon 1.由数据集构造成一个K-近邻图$G_k$2.通过图的划分算法将图$G_k$划分成大量的子图，每个子图代表一个初始子簇3.凝聚式层次聚类 Chameleon跟CURE和DBSCAN相比，在发现高质量的任意形状的聚类方面有更强的能力。但是，在最坏的情况下，高维数据的处理代价可能对n个对象需要$O(n^2)$的时间。 BIRCH 用到了$CF&amp;lt;n, LS, SS&amp;gt;$CF-tree类似于B-树，有两个参数：内部节点平衡因子$B$，叶节点平衡因子$L$，簇半径阈值$T$。1.自上而下选择最近的子节点2.到达子节点后，检查最近的元组$CF_i$能否吸收此数据点若能吸收，则更新CF值否则考虑是否可以添加一个新的元组如果可以，则添加一个新的元组否则，分裂最远的一对元组，作为种子，按最近距离重新分配其它元组3.更新每个非叶节点的CF信息，如果分裂节点，在父节点中插入新的元组，检查分裂，直到root BIRCH优点：1.节省内存。叶子节点放在磁盘分区2. 在对树进行插入或查找操作很快。3.一遍扫描数据库即可建树。4.可识别噪声点。5. 可作为其他聚类算法的预处理过程BIRCH缺点：1.结果依赖于数据点的插入顺序。2.对非球状的簇聚类效果不好。3.对高维数据聚类效果不好。4.最后得出来的簇可能和自然簇相差很大。5.在整个过程中算法一旦中断，一切必须从头再来。6.局部性 *BUBBLE 把BIRCH算法的中心和半径概念推广到普通的距离空间   *BUBBLE-FM 通过减少距离的计算次数，提高了BUBBLE算法的效率   Probabilistic agglomerative clustering 距离度量用： 如果dist小于零，则合并两个簇。 易于理解一般跟其他凝聚式层次聚类算法的效率差不多但是：it outputs only one hierarchy with respect to a chosen probabilistic model; it cannot handle the uncertainty of cluster hierarchies.</summary></entry><entry><title type="html">聚类算法总结 - Partitional Clustering</title><link href="http://localhost:4000/datamining/2015/09/21/partitinoal-clustering.html" rel="alternate" type="text/html" title="聚类算法总结 - Partitional Clustering" /><published>2015-09-21T10:31:05+08:00</published><updated>2015-09-21T10:31:05+08:00</updated><id>http://localhost:4000/datamining/2015/09/21/partitinoal-clustering</id><content type="html" xml:base="http://localhost:4000/datamining/2015/09/21/partitinoal-clustering.html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;算法&lt;/th&gt;
      &lt;th&gt;概括&lt;/th&gt;
      &lt;th&gt;优缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;k-means&lt;/td&gt;
      &lt;td&gt;每次从类中求均值作为中心点&lt;br /&gt;用到了EM的思想&lt;br /&gt;目标是最小化sum of squared error&lt;/td&gt;
      &lt;td&gt;要求预设k值&lt;br /&gt;易受噪音和离异点的影响 &lt;br /&gt;对不规则形状的类聚类效果不好&lt;br /&gt;不保证全局最优&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k-means++&lt;/td&gt;
      &lt;td&gt;目标是找到k个合理的初始种子点给k-means。&lt;br /&gt;1. 随机挑个随机点当“种子点”&lt;br /&gt;2. 对于每个点，计算其和最近的“种子点”的距离D(x)并保存，然后把这些距离加起来得到Sum(D(x))。&lt;br /&gt;3. 再取一个随机值，用权重的方式来取计算下一个“种子点”。这个算法的实现是，先取一个能落在Sum(D(x))中的随机值Random，然后用Random -= D(x)，直到其&amp;lt;=0，此时的点就是下一个“种子点”。&lt;br /&gt;4. 重复2和3直到k个中心被选出来&lt;br /&gt;5. 利用这k个初始的聚类中心来运行标准的k-means算法&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k-modes&lt;/td&gt;
      &lt;td&gt;K-Means算法的扩展&lt;br /&gt;对于分类型数据，用mode求中心点&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k-prototypes&lt;/td&gt;
      &lt;td&gt;结合了k-means和k-modes&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;k-medoids&lt;/td&gt;
      &lt;td&gt;每次从类中找一个具体的点来做中心点。目标是最小化absolute error。&lt;br /&gt;PAM是一种典型的k-medoids实现。&lt;/td&gt;
      &lt;td&gt;对噪音和离异点不那么敏感&lt;br /&gt;然而计算量大很多&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CLARA&lt;/td&gt;
      &lt;td&gt;先抽样，再用PAM&lt;/td&gt;
      &lt;td&gt;对于大数据比PAM好点&lt;br /&gt;主要是看sample的效果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CLARANS&lt;/td&gt;
      &lt;td&gt;每次随机的抓一个medoid跟一般点，然后判断，这两者如果替换的话，能不能减小absolute-error&lt;/td&gt;
      &lt;td&gt;融合了PAM和CLARA两者的优点，是第一个用于空间数据库的聚类算法&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">算法 概括 优缺点 k-means 每次从类中求均值作为中心点用到了EM的思想目标是最小化sum of squared error 要求预设k值易受噪音和离异点的影响 对不规则形状的类聚类效果不好不保证全局最优 k-means++ 目标是找到k个合理的初始种子点给k-means。1. 随机挑个随机点当“种子点”2. 对于每个点，计算其和最近的“种子点”的距离D(x)并保存，然后把这些距离加起来得到Sum(D(x))。3. 再取一个随机值，用权重的方式来取计算下一个“种子点”。这个算法的实现是，先取一个能落在Sum(D(x))中的随机值Random，然后用Random -= D(x)，直到其&amp;lt;=0，此时的点就是下一个“种子点”。4. 重复2和3直到k个中心被选出来5. 利用这k个初始的聚类中心来运行标准的k-means算法   k-modes K-Means算法的扩展对于分类型数据，用mode求中心点   k-prototypes 结合了k-means和k-modes   k-medoids 每次从类中找一个具体的点来做中心点。目标是最小化absolute error。PAM是一种典型的k-medoids实现。 对噪音和离异点不那么敏感然而计算量大很多 CLARA 先抽样，再用PAM 对于大数据比PAM好点主要是看sample的效果 CLARANS 每次随机的抓一个medoid跟一般点，然后判断，这两者如果替换的话，能不能减小absolute-error 融合了PAM和CLARA两者的优点，是第一个用于空间数据库的聚类算法</summary></entry><entry><title type="html">《30天自制操作系统》笔记五六</title><link href="http://localhost:4000/learning-note/2014/04/23/30days-os-part56.html" rel="alternate" type="text/html" title="《30天自制操作系统》笔记五六" /><published>2014-04-23T15:22:11+08:00</published><updated>2014-04-23T15:22:11+08:00</updated><id>http://localhost:4000/learning-note/2014/04/23/30days-os-part56</id><content type="html" xml:base="http://localhost:4000/learning-note/2014/04/23/30days-os-part56.html">&lt;p&gt;书上第五六天所涉及的内容主要是GDT、IDT以及PIC。这两部分我就合在一起写好了。（主要的原因是做完第五天的以后看到代码乱得惨不忍睹，就自己开始整理了一下，随后又发现第六天就是讲分割源文件的，所以就继续看了下去。）&lt;/p&gt;

&lt;p&gt;第五天一上来，作者就介绍了结构体。于是，出现了struct boot_info，struct seg_desc，以及struct gate_desc三者。（命名我是按照自己的习惯来改动的。）&lt;/p&gt;

&lt;p&gt;C语言语法上的东西就不提了。&lt;/p&gt;

&lt;p&gt;有点意思的是，继之前恶心简洁的图形化界面之后，我们这次来做文字显示。&lt;/p&gt;

&lt;p&gt;字体怎么来呢？最简单的一种方法就是按照之前做图像的时候的方法来做，也就是用boxfill8()，但是这样也太不专业了吧= =&lt;/p&gt;

&lt;p&gt;我们有一种好一点的方法，就是重写一个putfont8()函数，用来做字符显示。（ps：后来我改名为print_char()了）直接用作者给的hankaku.txt来导入字体。（其实这个字体包也没有多高端嘛……要用到新的工具makefont.exe。可以从hankaku.txt得到hankaku.bin。之后我们再用bin2obj.exe来将其转化为hankaku.obj文件。同时，对应的修改Makefile。&lt;/p&gt;

&lt;p&gt;值得注意的是：一定要加上”$BIN2OBJ ……“的说明！当时就是因为抄漏而导致了大量的失败。&lt;/p&gt;

&lt;p&gt;而显示变量名按照上面的来做基本也没问题。不过不知道为什么，到后面我多加”#include “bootpack.h”“语句之后，直接就只声明“char s[40]”是不够的，要初始化！可以是”char s[40]={‘0’}”。如果没有初始化，就会发现那个字符就是显示不出来，然后你还以为是print_str或者print_char的问题，对照源代码N次！！！（TAT）&lt;/p&gt;

&lt;p&gt;再来是鼠标的指针，这个其实还是蛮无聊有趣的。为了凸显我跟作者的不一样，我把指针弄成了8x8大小的，结果……其实也还是能用的，而且大小我（我不是处女座……）也刚好合适。&lt;/p&gt;

&lt;p&gt;文件分割不难，略过。也就是多出了graphic.c，dsctbl.c，以及后面的int.c。&lt;/p&gt;

&lt;p&gt;有一点是新学习到的，那就是Makefile的一般规则：&lt;/p&gt;

&lt;h1 id=&quot;general-rules-for-gas-nas-and-obj&quot;&gt;general rules for *.gas, *.nas and *.obj&lt;/h1&gt;
&lt;p&gt;%.gas : %.c Makefile
	$(CC1) -o $&lt;em&gt;.gas $&lt;/em&gt;.c
%.nas : %.gas Makefile
	$(GAS2NASK) $&lt;em&gt;.gas $&lt;/em&gt;.nas
%.obj : %.nas Makefile
	$(NASK) $&lt;em&gt;.nas $&lt;/em&gt;.obj $*.lst
关于Makefile，有个很详细的教程：http://bbs.chinaunix.net/thread-408225-1-1.html
之后得找时间认真学习一下才行。&lt;/p&gt;

&lt;p&gt;本次学习遇到的第一个重难点在于GDT以及IDT。&lt;/p&gt;

&lt;p&gt;其实作者的文笔还是挺好的，写得很顺畅。（虽然到后来发现他有些地方机智的绕掉了……）&lt;/p&gt;

&lt;p&gt;该记住的有：&lt;/p&gt;

&lt;p&gt;GDT大小为2^13*(8B) = 64KB&lt;/p&gt;

&lt;p&gt;/* segment descriptor, 8B &lt;em&gt;/
/&lt;/em&gt; base	       : base_low(2B), base_mid(1B) and base_high(1B)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;limit       : limit_low(1B) and limit_high(1B)&lt;/li&gt;
  &lt;li&gt;access_right: the highest bit is Gbit, when Gbit==1, 
              the unit of limit is PAGE; the highest 4bits are put into the 
      highest 4bits of limit_high. thus, to program, access_right
      is xxxx0000xxxxxxxx; the highest 4bits are “GD00”(used after 
      386), G is Gbit, D means 32-mode or 16-mode.
      lowest 8bits:
      0x00: unused descriptor table
      0x92: for system. RW-.
      0x9a: for system. R-X.
      0xf2: for applications. RW-.
      0xfa: for applications. R-X.
 */
struct seg_desc {
 short 	limit_low;
 short 	base_low;
 char 	base_mid; 
 char 	access_right;
 char 	limit_high; 
 char 	base_high;
};
而后面的gate_desc，类比一下就好。
set_seg_desc，set_gate_desc，init_gdt_idt就慢慢看代码吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C不能直接给GDTR赋值，所以要用load_gdtr，在naskfunc.nas中：&lt;/p&gt;

&lt;p&gt;_load_gdtr:		; void load_gdtr(int limit, int addr);
	; “MOV [ESP+6] [ESP+4]”
	MOV	AX, [ESP+4]	; limit
	MOV	[ESP+6], AX
	LGDT	[ESP+6]
	RET
看起来，这段函数似乎做的就是”MOV [ESP+6] [ESP+4]”但是为什么要这么做呢？为什么不直接”LGDT [ESP+4]”呢？
这其中可是大有奥秘的。&lt;/p&gt;

&lt;p&gt;首先，GDTR的低16位是段上限，高32位是地址。我们不能直接用MOV来赋值，而只能直接指定一个内存地址，让它去读这48位。想想看，假设我们传的段上限是0x0000ffff，而地址是00270000（事实上我们用的也就是这个）。这时候，地址从ESP+4往高处走是：【FF FF 00 00 00 00 27 00】。但我们希望给GDTR的是这样一部分：【FF FF 00 00 27 00】那可以看到，作者在这里把ESP+4赋值到ESP+6，然后就变成了【FF FF FF FF 00 00 27 00】，只要直接从ESP+6开始读就可以了。&lt;/p&gt;

&lt;p&gt;哎，在这里实在不得不感叹一声作者太神了！事实上如果你传参数的时候，两个参数的位置如果换一下的话，你会发现很不好处理！（我一开始是想这么干来着。）&lt;/p&gt;

&lt;p&gt;set_seg_desc太高深，跳过。（作者也没讲多少）&lt;/p&gt;

&lt;p&gt;然后就到PIC。一到硬件就各种蛋疼哎！&lt;/p&gt;

&lt;p&gt;PIC指的是Programmable interrupt controller。&lt;/p&gt;

&lt;p&gt;然后看图：&lt;/p&gt;

&lt;p&gt;用图比较容易理解。&lt;/p&gt;

&lt;p&gt;简而言之，PIC监视着输入管脚的8个中断信号，只要有一个中断信号进来，就将唯一的输出管脚信号变成ON，并通知CPU。&lt;/p&gt;

&lt;p&gt;然后下面是一段咋看之下很不明觉厉的代码：&lt;/p&gt;

&lt;p&gt;void init_pic(void);&lt;/p&gt;

&lt;p&gt;#define PIC0_ICW1	0x0020
#define PIC0_OCW2	0x0020
#define PIC0_IMR	0x0021
#define PIC0_ICW2	0x0021
#define PIC0_ICW3	0x0021
#define PIC0_ICW4	0x0021
#define PIC1_ICW1	0x00a0
#define PIC1_OCW2	0x00a0
#define PIC1_IMR	0x00a1
#define PIC1_ICW2	0x00a1
#define PIC1_ICW3	0x00a1
#define PIC1_ICW4	0x00a1 
/* Initialization of pic &lt;em&gt;/
void init_pic (void) {
	io_out8(PIC0_IMR,  0xff  ); /&lt;/em&gt; disable all interrupts &lt;em&gt;/
	io_out8(PIC1_IMR,  0xff  ); /&lt;/em&gt; disable all interrupts */&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;io_out8(PIC0_ICW1, 0x11  ); /* edge trigger mode*/
io_out8(PIC0_ICW2, 0x20  ); /* IRQ-7 is received by INT20-27 */
io_out8(PIC0_ICW3, 1 &amp;lt;&amp;lt; 2); /* PIC1 is connected by IRQ2*/
io_out8(PIC0_ICW4, 0x01  ); /* no-buffer mode */

io_out8(PIC1_ICW1, 0x11  ); /* edge trigger mode */
io_out8(PIC1_ICW2, 0x28  ); /* IRQ-15 is received by INT28-2f */
io_out8(PIC1_ICW3, 2     ); /* PIC1 is connected by IRQ2 */
io_out8(PIC1_ICW4, 0x01  ); /* no-buffer mode */

io_out8(PIC0_IMR,  0xfb  ); /* 11111011 disable all except PIC1 */
io_out8(PIC1_IMR,  0xff  ); /* 11111111 disable all interrupt */ } 简单的翻译一下，IMR指的是interrupt mask register，ICW指的是&quot;initial control word&quot;，都是8位寄存器。 IMR中8位分别对应8个IRQ信号，如果某一位为1，则该为对应的信号被屏蔽，PIC就忽略之。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ICW不一定是16位，因硬件而不同。有4个，分别编号1~4，共有4个字节的数据。&lt;/p&gt;

&lt;p&gt;ICW1和4与硬件有关，忽略之。&lt;/p&gt;

&lt;p&gt;ICW3是有关主从连接的设定，对主PIC而言，第几号IRQ与从PIC相连，是用8位来决定的。如果把这些为全部设为1，则主PIC能驱动8个从PIC。&lt;/p&gt;

&lt;p&gt;不过呢……这个是硬件决定的，我们也无力。&lt;/p&gt;

&lt;p&gt;所以只能改ICW2咯。&lt;/p&gt;

&lt;p&gt;ICW2决定了IRQ以哪一号中断通知CPU。通过PIC用数据信号线传送给CPU“0xcd 0x??”来实现的。这里的0xcd实际上就是调用BIOS时用的INT指令。&lt;/p&gt;

&lt;p&gt;这次以INT0x20~0x2f接收中断信号IRQ0~15而设定的。&lt;/p&gt;

&lt;p&gt;开始看程序，注意鼠标时IRQ12, 键盘是IRQ1。&lt;/p&gt;

&lt;p&gt;void inthandler21(int &lt;em&gt;esp)
/&lt;/em&gt; interrupt from PS/2 keyboard */
{
	struct boot_info *binfo = (struct boot_info *) BOOT_ADDR;
	boxfill8(binfo-&amp;gt;vram, binfo-&amp;gt;scrnx, BLACK, 0, 0, 32 * 8 - 1, 15);
	print_str(binfo-&amp;gt;vram, binfo-&amp;gt;scrnx, 0, 0, WHITE, “INT 21 (IRQ-1) : PS/2 keyboard”);
	for (;;) {
		io_hlt();
	}
}
完了之后还得让它执行IRETD：
_asm_inthandler21:
		PUSH	ES
		PUSH	DS
		PUSHAD
		MOV		EAX,ESP
		PUSH	EAX
		MOV		AX,SS
		MOV		DS,AX
		MOV		ES,AX
		CALL	_inthandler21
		POP		EAX
		POPAD
		POP		DS
		POP		ES
		IRETD
关于栈，不解释。&lt;/p&gt;

&lt;p&gt;这些差不多就是今天全部的内容了。（唉，累……）&lt;/p&gt;</content><author><name></name></author><summary type="html">书上第五六天所涉及的内容主要是GDT、IDT以及PIC。这两部分我就合在一起写好了。（主要的原因是做完第五天的以后看到代码乱得惨不忍睹，就自己开始整理了一下，随后又发现第六天就是讲分割源文件的，所以就继续看了下去。）</summary></entry><entry><title type="html">《30天自制操作系统》笔记四</title><link href="http://localhost:4000/learning-note/2014/04/22/30days-os-part4.html" rel="alternate" type="text/html" title="《30天自制操作系统》笔记四" /><published>2014-04-22T11:22:17+08:00</published><updated>2014-04-22T11:22:17+08:00</updated><id>http://localhost:4000/learning-note/2014/04/22/30days-os-part4</id><content type="html" xml:base="http://localhost:4000/learning-note/2014/04/22/30days-os-part4.html">&lt;p&gt;第四天我们所要做的事情是使用指针以及显示一个简单的图形界面。&lt;/p&gt;

&lt;p&gt;对于有C语言基础的人来说，指针这一部分基本没问题，主要还是图形界面的设置上。&lt;/p&gt;

&lt;p&gt;我们要修改的是bootpack.c以及naskfunc.nas。在naskfunc.nas中加入了一些IO相关的函数：&lt;/p&gt;

&lt;p&gt;; io interrupt
GLOBAL		_io_hlt, _io_cli, _io_sti, _io_stihlt
; io in
GLOBAL		_io_in8, _io_in16, _io_in32
; io out
GLOBAL 	_io_out8, _io_out16, _io_out32
; about EFLAGS
GLOBAL		_io_load_eflags, _io_store_eflags
值得一提的是最后的两个函数。EFLAGS是一个存储着各种标志的寄存器。&lt;/p&gt;

&lt;p&gt;接下来就是C语言的天地了。&lt;/p&gt;

&lt;p&gt;关于颜色，由于这次使用的是320x200的8位颜色模式，也就是最多只能使用0~255共256种颜色了。这里我们只用16种：&lt;/p&gt;

&lt;p&gt;先来初始化调色板：init_palette()&lt;/p&gt;

&lt;p&gt;void init_palette (void) {
	static unsigned char table_rgb[16 * 3] = {
		/&lt;em&gt;R, G, B&lt;/em&gt;/
		0x00, 0x00, 0x00,	/*  0:black&lt;em&gt;/
		0xff, 0x00, 0x00,	/&lt;/em&gt;  1:light red&lt;em&gt;/
		0x00, 0xff, 0x00,	/&lt;/em&gt;  2:light green&lt;em&gt;/
		0xff, 0xff, 0x00,	/&lt;/em&gt;  3:light yellow&lt;em&gt;/
		0x00, 0x00, 0xff,	/&lt;/em&gt;  4:light blue&lt;em&gt;/
		0xff, 0x00, 0xff,	/&lt;/em&gt;  5:light purple&lt;em&gt;/
		0x00, 0xff, 0xff,	/&lt;/em&gt;  6:soft light blue&lt;em&gt;/
		0xff, 0xff, 0xff,	/&lt;/em&gt;  7:white&lt;em&gt;/
		0xc6, 0xc6, 0xc6,	/&lt;/em&gt;  8:light grey&lt;em&gt;/
		0x84, 0x00, 0x00,	/&lt;/em&gt;  9:dark red&lt;em&gt;/
		0x00, 0x84, 0x00,	/&lt;/em&gt; 10:dark green&lt;em&gt;/
		0x84, 0x84, 0x00,	/&lt;/em&gt; 11:dark yellow&lt;em&gt;/
		0x00, 0x00, 0x84,	/&lt;/em&gt; 12:dark blue&lt;em&gt;/
		0x84, 0x00, 0x84,	/&lt;/em&gt; 13:dark purple&lt;em&gt;/
		0x00, 0x84, 0x84,	/&lt;/em&gt; 14:soft dark blue&lt;em&gt;/
		0x84, 0x84, 0x84	/&lt;/em&gt; 15:dark grey*/
	};
	set_palette (0, 15, table_rgb);
	return ;
}
其实主要就是对“调色板”table_rgb进行声明（虽然看起来真的很恶心……），然后再用set_palette来设置：
void set_palette (int start, int end, unsigned char *rgb) {
	int i;
	int eflags = io_load_eflags();
	io_cli();&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;io_out8(0x03c8, start);	
for (i = start; i &amp;lt;= end; ++i) {
	io_out8(0x03c9, *(rgb+0) / 4);
	io_out8(0x03c9, *(rgb+1) / 4);
	io_out8(0x03c9, *(rgb+2) / 4);
	rgb += 3;
}
io_store_eflags(eflags);
return ; } 这里跟作者给的代码有一点点的不同就在于我把rgb[0]改成了*(rgb+0)，主要是觉得在之前声明 的时候rgb是数组，如果第一眼看循环体内的代码可能会觉得是只用到了rgb数组的前三个。事实上，因为后面还有一句“rgb+=3”，使得代码是按照声明的部分当中一行一行的来进行io_out的。 这里我们还用到了和eflags有关的几个函数，是因为要进行防止设置调色板的这个过程被中断了。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;而为什么是这样的来io_out，0x03c8以及0x03c9又是哪里来的呢？这里详情可以看：http://community.osdev.info/?VGA&lt;/p&gt;

&lt;p&gt;书上的说法是：&lt;/p&gt;

&lt;p&gt;完了以后我们就可以开始用色了。&lt;/p&gt;

&lt;p&gt;这里书上的参考函数：&lt;/p&gt;

&lt;p&gt;void boxfill8(unsigned char *vram, int xsize, unsigned char c, 
		int x0, int y0, int x1, int y1) {
	int x, y;
	for (y = y0; y &amp;lt;= y1; y++)
		for (x = x0; x &amp;lt;= x1; x++)
			vram[y * xsize + x] = c;
	return;
}
就是绘制矩形。
其中c代表的是color的编号，这里被我重新宏定义了（真不明白作者的宏定义为什么他自己可以看得懂……）&lt;/p&gt;

&lt;p&gt;/* colors */
#define BLACK		0
#define LIGHT_RED	1
#define LIGHT_GREEN	2
#define LIGHT_YELLOW	3
#define LIGHT_BLUE	4
#define LIGHT_PURPLE	5
#define SOFT_LIGHT_BLUE	6
#define WHITE		7
#define LIGHT_GREY	8
#define DARK_RED	9
#define DARK_GREEN	10
#define DARK_YELLOW	11
#define DARK_BLUE	12
#define DARK_PURPLE	13
#define SOFT_DARK_BLUE	14
#define DARK_GREY	15
今天的也就这么多了。&lt;/p&gt;</content><author><name></name></author><summary type="html">第四天我们所要做的事情是使用指针以及显示一个简单的图形界面。</summary></entry></feed>