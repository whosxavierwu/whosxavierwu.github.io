<p>最近重新开始了在刷题，也尽量多写一写吧。</p>

<h1 id="一题目大意">一、题目大意</h1>

<p>指定有N对括号，需要输出所有可能的、形式上正确的括号组合情况。例如N=3时，有</p>

<blockquote>

  <p>[
  “((()))”,
  “(()())”,
  “(())()”,
  “()(())”,
  “()()()”
]</p>
</blockquote>

<p>这五种可能的排列。</p>

<h1 id="二解题思路">二、解题思路：</h1>

<p>主要参考两篇文章：</p>

<p>https://leetcode.com/problems/generate-parentheses/solution/</p>

<p>https://blog.csdn.net/runningtortoises/article/details/45625363</p>

<p>分别有这么几种思路：</p>

<p>1、暴力破解</p>

<p>把所有可能的串都输出来，然后逐个判断合法性。</p>

<p>2、回溯</p>

<p>3、Closure Number</p>

<p>这种思路是我最为喜欢的一种。我们可以发现，一个合法的串总是可以递归的表示为：</p>

<blockquote>
  <p><strong>(</strong>子串1<strong>)</strong>子串2</p>
</blockquote>

<p>两个合法的子串以及一对括号。</p>

<p>想到这一点之后，其实后面的思路很自然的也能想通了：
两个子串的括号对数为N-1，我们只需要遍历所有可能的组合情况就行了，从(0, N-1), (1, N-2), …, (N-1, 0)。
这种思路实际上是按顺序生成 0, 1, …, N 的所有解。</p>

<p>4、增量</p>

<p>不断的判断左右括号的数量，进而选择添加左括号还是添加右括号。</p>

<h1 id="三具体实现">三、具体实现：</h1>

<p>这里就只贴第二种思路的吧。</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">"""
    递归版
    """</span>
    <span class="k">def</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateParenthesis</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generateParenthesis</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">c</span><span class="p">):</span>
                    <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'({}){}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ans</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">"""
    非递归版
    """</span>
    <span class="k">def</span> <span class="nf">generateParenthesis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="s">"""
        :type n: int
        :rtype: List[str]
        """</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>
        <span class="n">res_dict</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:[</span><span class="s">''</span><span class="p">]}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">tmp_res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">left_count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="n">res_dict</span><span class="p">[</span><span class="n">left_count</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">right</span> <span class="ow">in</span> <span class="n">res_dict</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">left_count</span><span class="p">]:</span>
                        <span class="n">tmp_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'({}){}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span>
            <span class="n">res_dict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp_res</span>
        <span class="k">return</span> <span class="n">res_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span></pre></td></tr></tbody></table></code></pre></figure>

<p>四、其他</p>

<p>python的好处在于，代码可以相当精简。同样的算法在c里面去实现的话，难度往往会大很多。
python用久了之后，会发现自己“变笨了”，差不多连c都不会用了。
所以偶尔还是得多练练手的。</p>

